# justfile — Git 그래프 관리 유틸 

default: hello 

hello:
    echo Hello, World!

set shell := ["bash", "-euo", "pipefail", "-c"]

# -------------------------
# GRAPH & CLEAN (1~5)
# -------------------------
lg:
	git log --graph --decorate --pretty=format:'%C(yellow)%h%Creset %Cgreen%ad%Creset %C(auto)%d%Creset %s %C(blue)<%an>%Creset' --date=short -n 50 | less -R

lg-all:
	git log --all --graph --decorate --pretty=format:'%C(yellow)%h%Creset %Cgreen%ad%Creset %C(auto)%d%Creset %s %C(blue)<%an>%Creset' --date=short | less -R

graph-churn:
	git log --since="3 months ago" --name-only --pretty=format: | grep -v '^\s*$$' | sort | uniq -c | sort -rn | head -20 | less -R

clean-merged:
	BASE=$$(git symbolic-ref --short HEAD); \
	git branch --merged "$$BASE" | grep -vE "^\*|^($$BASE|main|master|develop)$$" | xargs -r git branch -d

prune-remote:
	git fetch --all --prune && git remote prune origin || true

# -------------------------
# FETCH/PULL/PUSH (6~10)
# -------------------------
fetch-all:
	git fetch --all --prune

pull-rebase:
	git pull --rebase --autostash --ff-only

push-safe:
	git push --porcelain

set-upstream:
	BR=$$(git symbolic-ref --short HEAD); git push -u origin "$$BR"

push-lease:
	BR=$$(git symbolic-ref --short HEAD); git push --force-with-lease origin "$$BR"

# -------------------------
# RESET / REVERT (11~15)
# -------------------------
reset-soft target="HEAD~1":
	git reset --soft {{target}}

reset-mixed target="HEAD~1":
	git reset --mixed {{target}}

reset-hard-pick:
	TARGET=$$(git log --oneline | fzf --prompt='reset --hard to > ' | awk '{print $$1}'); \
	[ -n "$$TARGET" ] && git reset --hard "$$TARGET"

revert-range:
	SEL=$$(git log --oneline | fzf -m --height=60% --prompt='pick 2 > '); \
	A=$$(echo "$$SEL" | tail -n1 | awk '{print $$1}'); \
	B=$$(echo "$$SEL" | head -n1 | awk '{print $$1}'); \
	[ -n "$$A" ] && [ -n "$$B" ] && git revert -n "$$B..$$A"

reflog-browse:
	T=$$(git reflog --date=local | fzf --prompt='reflog checkout > ' | awk '{print $$1}'); \
	[ -n "$$T" ] && git checkout "$$T"

# -------------------------
# STASH (16~19)
# -------------------------
stash-wip:
	git stash push -u -m "WIP $$(date +%F_%T)"

stash-pick-pop:
	S=$$(git stash list | fzf --prompt='stash pop > ' | cut -d: -f1); \
	[ -n "$$S" ] && git stash pop "$$S"

stash-keep:
	git stash push -k -m "KEEP $$(date +%F_%T)"

stash-diff:
	S=$$(git stash list | fzf --prompt='stash diff > ' | cut -d: -f1); \
	[ -n "$$S" ] && git stash show -p "$$S" | less -R

# -------------------------
# REBASE / FIXUP / ONTO (20~22)
# -------------------------
rebase-onto-pick:
	NB=$$(git for-each-ref --format='%(refname:short)' refs/heads refs/remotes | sort -u | fzf --prompt='new base > '); \
	UP=$$(git for-each-ref --format='%(refname:short)' refs/heads refs/remotes | sort -u | fzf --prompt='upstream > '); \
	TP=$$(git for-each-ref --format='%(refname:short)' refs/heads | sort -u | fzf --prompt='topic > '); \
	[ -n "$$NB" ] && [ -n "$$UP" ] && [ -n "$$TP" ] && git rebase --onto "$$NB" "$$UP" "$$TP"

rebase-autosquash range="HEAD~20":
	git rebase -i --rebase-merges --autosquash {{range}}

reword-last msg="fix: reword last commit":
	git commit --amend --only --no-edit -m "{{msg}}"

# -------------------------
# SQUASH MERGE (23~24)
# -------------------------
squash-merge:
	BR=$$(git for-each-ref --format='%(refname:short)' refs/heads | sort -u | fzf --prompt='squash from > '); \
	[ -n "$$BR" ] && git merge --squash "$$BR" && git commit -m "squash: merge $$BR into $$(git rev-parse --abbrev-ref HEAD)"

squash-last-n N="3":
	git reset --soft HEAD~{{N}} && git commit -m "squash: compress last {{N}} commits"

# -------------------------
# WORKTREE (25~27)
# -------------------------
wt-add dir="./wt-$(git branch --show-current)":
	BR=$$(git for-each-ref --format='%(refname:short)' refs/heads | sort -u | fzf --prompt='worktree branch > '); \
	[ -n "$$BR" ] && git worktree add {{dir}} "$$BR"

wt-prune:
	git worktree prune

wt-list:
	git worktree list

# -------------------------
# CHERRY-PICK / SPLIT (28~29)
# -------------------------
pick-range:
	SEL=$$(git log --oneline | fzf -m --height=60% --prompt='pick 2 > '); \
	A=$$(echo "$$SEL" | tail -n1 | awk '{print $$1}'); \
	B=$$(echo "$$SEL" | head -n1 | awk '{print $$1}'); \
	[ -n "$$A" ] && [ -n "$$B" ] && git cherry-pick "$$B..$$A"

split-last:
	git reset --soft HEAD~1 && echo "Now stage chunks and commit separately."

# -------------------------
# DIFF & BLAME (30~31)
# -------------------------
diff-pick2:
	REFSEL=$$(git for-each-ref --format='%(refname:short)' refs/heads refs/remotes | sort -u | fzf -m --height=60% --reverse --prompt='Pick 2 > '); \
	A=$$(echo "$$REFSEL" | head -n1); \
	B=$$(echo "$$REFSEL" | tail -n1); \
	[ -n "$$A" ] && [ -n "$$B" ] && git diff "$$A" "$$B" | diffnav

blame-pick-file:
	FILE=$$(git ls-files | fzf --prompt='blame file > '); \
	[ -n "$$FILE" ] && git blame -w -C -C --date=short "$$FILE" | less -R

# -------------------------
# RESTORE / CHECKOUT (32~33)
# -------------------------
restore-from:
	SRC=$$(git for-each-ref --format='%(refname:short)' refs/heads refs/remotes | sort -u | fzf --prompt='from ref > '); \
	FILE=$$(git ls-tree -r --name-only "$$SRC" | fzf --prompt='pick file > '); \
	[ -n "$$SRC" ] && [ -n "$$FILE" ] && git checkout "$$SRC" -- "$$FILE"

switch-pick:
	BR=$$(git for-each-ref --format='%(refname:short)' refs/heads | sort -u | fzf --prompt='switch > '); \
	[ -n "$$BR" ] && git switch "$$BR"

# -------------------------
# TAG / RELEASE (34~35)
# -------------------------
tag-annotate tag="v$(date +%Y.%m.%d)" msg="Release $(date +%Y.%m.%d)":
	git tag -a {{tag}} -m "{{msg}}" && git push origin {{tag}}

move-tag tag target="HEAD":
	git tag -f {{tag}} {{target}} && git push -f origin "refs/tags/{{tag}}"

# -------------------------
# MISC (36~39)
# -------------------------
author-fix name email:
	GIT_COMMITTER_NAME="{{name}}" GIT_COMMITTER_EMAIL="{{email}}" \
	GIT_AUTHOR_NAME="{{name}}"    GIT_AUTHOR_EMAIL="{{email}}" \
	git commit --amend --no-edit --reset-author

bisect-run test:
	BAD=$$(git log --oneline | fzf --prompt='pick BAD > ' | awk '{print $$1}'); \
	GOOD=$$(git log --oneline | fzf --prompt='pick GOOD > ' | awk '{print $$1}'); \
	git bisect start "$$BAD" "$$GOOD"; git bisect run {{test}} || true; git bisect reset

gc-vacuum:
	git gc --aggressive --prune=now && git fetch --all --prune

untracked-clean:
	git clean -xfd

# -------------------------
# HUNK (40~48)
# -------------------------
hunk-stage:
	git add -p

hunk-unstage:
	git reset -p

hunk-discard:
	git restore -p .

hunk-file-pick:
	git ls-files -m -o --exclude-standard | fzf -m --prompt='add -p files > ' | xargs -r -I{} sh -c 'git add -p -- "{}"'

hunk-commit-partial msg="partial: commit selected hunks":
	git add -p && git commit -m "{{msg}}"

hunk-show:
	(git diff | delta || git diff | diff-so-fancy || git diff) | less -R

hunk-apply-from:
	SRC=$$(git for-each-ref --format='%(refname:short)' refs/heads refs/remotes | sort -u | fzf --prompt='from ref > '); \
	FILE=$$(git ls-tree -r --name-only "$$SRC" | fzf --prompt='pick file > '); \
	[ -n "$$SRC" ] && [ -n "$$FILE" ] && git diff "$$SRC" -- "$$FILE" | git apply -p0

hunk-copy-file:
	SRC=$$(git for-each-ref --format='%(refname:short)' refs/heads refs/remotes | sort -u | fzf --prompt='from ref > '); \
	FILE=$$(git ls-tree -r --name-only "$$SRC" | fzf --prompt='pick file > '); \
	[ -n "$$SRC" ] && [ -n "$$FILE" ] && git checkout "$$SRC" -- "$$FILE"

hunk-split-file:
	echo "Use: git add -p <file> → commit → 반복해서 커밋 분리"

# -------------------------
# SUBMODULE (49~59)
# -------------------------
sm-init:
	git submodule init

sm-update:
	git submodule update --init --recursive

sm-update-remote:
	git submodule update --init --remote --recursive

sm-add url path branch="main":
	git submodule add -b {{branch}} {{url}} {{path}} && git commit -m "chore(submodule): add {{path}} ({{branch}})"

sm-set-branch br="main":
	NAMEPATH=$$(git config -f .gitmodules --name-only --get-regexp path | while read -r n; do p=$$(git config -f .gitmodules --get "$$n"); echo "$$n $$p"; done | fzf --prompt='pick submodule > '); \
	[ -n "$$NAMEPATH" ] || exit 0; \
	NAME=$$(echo "$$NAMEPATH" | awk '{print $$1}' | sed 's/\.path$$//'); \
	PATH_SM=$$(echo "$$NAMEPATH" | awk '{print $$2}'); \
	git config -f .gitmodules "$$NAME.branch" {{br}}; git submodule sync --recursive

sm-foreach-status:
	git submodule foreach 'echo "== $$name =="; git status -sb; echo'

sm-foreach-pull:
	git submodule foreach 'git fetch --all --prune; git pull --rebase --autostash --ff-only || true'

sm-foreach-branch br:
	git submodule foreach "git switch {{br}} || git checkout -b {{br}}"

sm-sync:
	git submodule sync --recursive

sm-absorbgitdirs:
	git submodule absorbgitdirs --all

sm-deinit:
	PICK=$$(git config -f .gitmodules --get-regexp path 2>/dev/null | awk '{print $$2}' | fzf -m --prompt='deinit paths > '); \
	[ -z "$$PICK" ] && exit 0; \
	echo "$$PICK" | while read -r P; do \
	  git submodule deinit -f "$$P" || true; \
	  rm -rf "$$P"; \
	  git rm -f "$$P" || true; \
	done; \
	git commit -m "chore(submodule): deinit/remove selected modules"
